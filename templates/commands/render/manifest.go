// Copyright 2023 The Authors (see AUTHORS file)
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package render

import (
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"net/url"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"github.com/benbjohnson/clock"
	"golang.org/x/mod/sumdb/dirhash"
	"gopkg.in/yaml.v3"

	"github.com/abcxyz/abc/templates/common"
	"github.com/abcxyz/abc/templates/model"
	manifest "github.com/abcxyz/abc/templates/model/manifest/v1alpha1"
)

// manifestDirName is the subdirectory underneath the destination directory
// where we'll write the manifest file.
const manifestDirName = ".abc"

// writeManifestParams are all the argument to writeManifest, wrapped in a
// struct because there are so many.
type writeManifestParams struct {
	// Fakeable time for testing.
	clock clock.Clock

	// CWD is used to determine whether the template location is canonical or
	// not, in the case where a template is installed from a local directory.
	cwd string

	// destDir is the template render output directory, where the manifest will be
	// written under the .abc directory.
	destDir string

	// dryRun creates the manifest in memory but doesn't write it to a file.
	dryRun bool

	// Used to determine the canonical source of the rendered template.
	cs canonicalSourcer

	// A fakeable filesystem for testing errors.
	fs common.FS

	// The set of values that were used as the template inputs; combined from
	// --input, --input-file, prompts, and defaults.
	inputs map[string]string

	// The SHA256 hash of each file created by the template rendering process
	// in the destination directory.
	outputHashes map[string][]byte

	// The raw template source location, not necessarily canonical.
	src string

	// The temp directory where the template was downloaded.
	templateDir string
}

// canonicalSourcer is the subset of the Downloader interface that is needed by
// the manifest code.
type canonicalSourcer interface {
	CanonicalSource(_ context.Context, cwd, destDir string) (string, bool, error)
}

// writeManifest creates a manifest struct, marshals it as YAML, and writes it
// to destDir/.abc/ .
func writeManifest(ctx context.Context, p *writeManifestParams) (rErr error) {
	canonicalSource, _, err := p.cs.CanonicalSource(ctx, p.cwd, p.destDir)
	if err != nil {
		return err //nolint:wrapcheck
	}

	m, err := buildManifest(ctx, p, canonicalSource)
	if err != nil {
		return err
	}

	buf, err := yaml.Marshal(m)
	if err != nil {
		return fmt.Errorf("failed marshaling Manifest when writing: %w", err)
	}

	filename, err := newManifestFilename(p, canonicalSource)
	if err != nil {
		return err
	}

	if p.dryRun {
		if _, err := p.fs.Stat(filename); err != nil {
			if common.IsStatNotExistErr(err) {
				// This is good. We don't want to overwrite an existing manifest file,
				// so that fact that it doesn't already exist is good news.
				return nil
			}
			return fmt.Errorf("Stat(): %w", err)
		}
		return fmt.Errorf("dry run failed, the output manifest file %q already exists", filename)
	}

	// Why O_EXCL? Because we don't want to overwrite an existing file. TODO test
	fh, err := p.fs.OpenFile(filename, os.O_CREATE|os.O_EXCL|os.O_WRONLY, common.OwnerRWPerms)
	if err != nil {
		return fmt.Errorf("OpenFile(%q): %w", filename, err)
	}
	defer func() {
		rErr = errors.Join(rErr, fh.Close())
	}()
	buf = append([]byte("# Generated by the \"abc templates\" command. Do not modify.\n"), buf...)
	if _, err := fh.Write(buf); err != nil {
		return fmt.Errorf("Write(%q): %w", filename, err)
	}

	return nil
}

// newManifestFilename outputs the filename that will be used for a newly rendered
// template (not an upgrade to an already-installed manifest). This includes the
// ".abc/" prefix.
func newManifestFilename(p *writeManifestParams, canonicalSource string) (string, error) {
	manifestDir := filepath.Join(p.destDir, manifestDirName)
	if err := p.fs.MkdirAll(manifestDir, common.OwnerRWXPerms); err != nil {
		return "", fmt.Errorf("failed creating %s directory to contain manifest: %w", manifestDir, err)
	}

	namePart := "nolocation"
	if canonicalSource != "" {
		namePart = url.PathEscape(canonicalSource)
	}

	// We include the creation time in the filename to disambiguate between
	// multiple installations of the same template that target the same
	// destination directory.
	timeStr := p.clock.Now().UTC().Format(time.RFC3339Nano)

	// Windows doesn't allow colons in filenames ðŸ™„
	timeStr = strings.ReplaceAll(timeStr, ":", "_")

	baseName := strings.Join(
		[]string{"manifest", namePart, timeStr},
		"_")
	baseName += ".lock.yaml"

	return filepath.Join(manifestDir, baseName), nil
}

// buildManifest constructs the manifest struct for the given parameters.
// canonicalSource is optional, it will be empty in the case where the template
// location is non-canonical (i.e. installing from ~/mytemplate).
func buildManifest(ctx context.Context, p *writeManifestParams, canonicalSource string) (*manifest.Manifest, error) {
	templateDirhash, err := dirhash.HashDir(p.templateDir, "", dirhash.Hash1)
	if err != nil {
		return nil, fmt.Errorf("dirhash.HashDir: %w", err)
	}

	inputList := make([]*manifest.Input, 0, len(p.inputs))
	for name, val := range p.inputs {
		inputList = append(inputList, &manifest.Input{
			Name:  model.String{Val: name},
			Value: model.String{Val: val},
		})
	}

	outputList := make([]*manifest.OutputHash, 0, len(p.outputHashes))
	for file, hash := range p.outputHashes {
		// For consistency with dirhash, we'll encode our hashes as
		// base64 with an "h1:" prefix indicating SHA256.
		hashStr := "h1:" + base64.StdEncoding.EncodeToString(hash)
		outputList = append(outputList, &manifest.OutputHash{
			File: model.String{Val: file},
			Hash: model.String{Val: hashStr},
		})
	}

	// Alphabetize the lists of inputs and outputs just to be deterministic and
	// civilized.
	sort.Slice(inputList, func(l, r int) bool {
		return inputList[l].Name.Val < inputList[r].Name.Val
	})
	sort.Slice(outputList, func(l, r int) bool {
		return outputList[l].File.Val < outputList[r].File.Val
	})

	now := p.clock.Now().UTC()

	return &manifest.Manifest{
		TemplateLocation: model.String{Val: canonicalSource}, // may be empty string if location isn't canonical
		TemplateDirhash:  model.String{Val: templateDirhash},
		CreationTime:     now,
		ModificationTime: now,
		Inputs:           inputList,
		OutputHashes:     outputList,
	}, nil
}
